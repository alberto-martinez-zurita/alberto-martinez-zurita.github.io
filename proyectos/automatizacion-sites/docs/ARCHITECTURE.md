# Z-Content Platform - Architecture Documentation

**Elite-Level System Design**
Version: 2.0
Last Updated: 2025-12-22
Status: Production-Ready

---

## Table of Contents

1. [Architectural Overview](#architectural-overview)
2. [Core Design Principles](#core-design-principles)
3. [System Components](#system-components)
4. [Data Flow Architecture](#data-flow-architecture)
5. [Layered Architecture](#layered-architecture)
6. [Design Patterns](#design-patterns)
7. [Multi-Tenant Strategy](#multi-tenant-strategy)
8. [Internationalization Architecture](#internationalization-architecture)
9. [SEO Architecture](#seo-architecture)
10. [Performance Architecture](#performance-architecture)
11. [Deployment Architecture](#deployment-architecture)
12. [Security Architecture](#security-architecture)
13. [Scalability & Extensibility](#scalability--extensibility)

---

## Architectural Overview

### System Purpose

Z-Content Platform is a **Static Site Generator (SSG)** designed for content sovereignty, semantic authority, and multi-tenant publishing. It transforms structured content (Markdown + YAML) into SEO-optimized, performance-first static websites.

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                         PRESENTATION LAYER                          │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │
│  │   Browser    │  │  Web Crawler │  │  AI Agents   │             │
│  │ (HTMX + JS)  │  │ (Googlebot)  │  │  (GPTBot)    │             │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘             │
└─────────┼──────────────────┼──────────────────┼────────────────────┘
          │                  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         STATIC HTML OUTPUT                          │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  output/                                                     │   │
│  │  ├── index.html (root redirect + hreflang)                  │   │
│  │  ├── robots.txt (crawl directives)                          │   │
│  │  ├── sitemap.xml (sitemap index)                            │   │
│  │  ├── en/                                                     │   │
│  │  │   ├── index.html (homepage)                              │   │
│  │  │   ├── sitemap.xml (language-specific)                    │   │
│  │  │   ├── sagas/{slug}/{episode}.html                        │   │
│  │  │   └── api/search-index.json                              │   │
│  │  ├── es/ (mirror structure)                                 │   │
│  │  └── static/                                                 │   │
│  │      ├── css/main.css                                        │   │
│  │      ├── assets/{site}/{saga}/{episode}/                    │   │
│  │      └── img/                                                │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
                               ▲
                               │ GENERATED BY
                               │
┌─────────────────────────────────────────────────────────────────────┐
│                      APPLICATION LAYER                              │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    HTMLRenderer                              │  │
│  │  - Jinja2 Templating Engine                                 │  │
│  │  - Markdown-to-HTML Conversion                              │  │
│  │  - SEO Metadata Injection                                   │  │
│  │  - Asset Path Normalization                                 │  │
│  │  - Multi-Language Orchestration                             │  │
│  └──────────────────┬───────────────────────────────────────────┘  │
└────────────────────┼──────────────────────────────────────────────┘
                     │ USES
                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       DOMAIN LAYER                                  │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐    │
│  │  Saga           │  │  Episode        │  │  AffiliateProduct│    │
│  │  - slug         │  │  - title        │  │  - name          │    │
│  │  - title        │  │  - content      │  │  - price         │    │
│  │  - episodes[]   │  │  - media        │  │  - links[]       │    │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘    │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                   SiteConfig                                │  │
│  │  - site_id, domain, language                               │  │
│  │  - branding (colors, logo)                                 │  │
│  │  - features (search, dark_mode)                            │  │
│  │  - seo (og_image, keywords)                                │  │
│  └─────────────────────────────────────────────────────────────┘  │
└────────────────────┬────────────────────────────────────────────────┘
                     │ POPULATED BY
                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ADAPTER LAYER                                  │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                FileSystemReader                              │  │
│  │  - load_site_config(site_id)                                │  │
│  │  - read_sagas(site_id, lang) → Iterator[Saga]               │  │
│  │  - read_episodes(site_id, saga_slug) → Iterator[Episode]    │  │
│  │  - read_products(site_id) → ProductCatalog                  │  │
│  │  - parse_frontmatter(content) → (metadata, body)            │  │
│  └──────────────────┬───────────────────────────────────────────┘  │
└────────────────────┼────────────────────────────────────────────────┘
                     │ READS FROM
                     ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    INFRASTRUCTURE LAYER                             │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              Filesystem Content Store                        │  │
│  │  data/sites/{site_id}/                                       │  │
│  │  ├── config.json                                             │  │
│  │  ├── products/*.yaml                                         │  │
│  │  ├── series/{saga}/                                          │  │
│  │  │   ├── meta.{lang}.yaml                                    │  │
│  │  │   └── ep-{num}-{slug}/                                    │  │
│  │  │       ├── content.{lang}.md                               │  │
│  │  │       └── assets/                                         │  │
│  │  └── posts/*.md                                              │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Core Design Principles

### 1. Clean Architecture (Uncle Bob)

**Dependency Rule**: Dependencies point inward, never outward.

```
┌─────────────────────────────────────────┐
│ External Interfaces (CLI, Web Server)  │  ← Outermost Layer
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│ Adapters (FileSystemReader, HTMLRenderer)│  ← Interface Adapters
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│ Use Cases (Build Site, Validate Config)│  ← Application Business Rules
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│ Entities (Saga, Episode, SiteConfig)   │  ← Enterprise Business Rules
└─────────────────────────────────────────┘
                   ▲
                   │ NO DEPENDENCIES ON OUTER LAYERS
```

**Benefits**:
- Domain logic independent of frameworks (Jinja2, Flask, etc.)
- Easy to test: Mock interfaces, test pure business logic
- Easy to extend: New content sources (API, CMS) don't affect domain

### 2. SOLID Principles

**Single Responsibility**
```python
# FileSystemReader: ONLY reads content from filesystem
class FileSystemReader(IContentReader):
    def read_sagas(self, site_id: str) -> Iterator[Saga]: ...

# HTMLRenderer: ONLY renders content to HTML
class HTMLRenderer(ISiteRenderer):
    def render_site(self, config, sagas, posts, products): ...
```

**Open/Closed Principle**
```python
# Open for extension (new IContentReader implementations)
# Closed for modification (domain models don't change)

class DatabaseReader(IContentReader):  # New adapter
    def read_sagas(self, site_id: str) -> Iterator[Saga]:
        # Fetch from PostgreSQL instead of filesystem
        ...
```

**Liskov Substitution**
```python
# Any IContentReader can be swapped without breaking build process
reader: IContentReader = FileSystemReader()
# OR
reader: IContentReader = DatabaseReader()
# OR
reader: IContentReader = APIReader()

# Build pipeline doesn't care about the source
sagas = list(reader.read_sagas("specbio"))
```

**Interface Segregation**
```python
# Interfaces are minimal and focused
class IContentReader(ABC):
    @abstractmethod
    def read_sagas(...) -> Iterator[Saga]: ...
    # No methods for rendering, caching, or other concerns

class ISiteRenderer(ABC):
    @abstractmethod
    def render_site(...) -> None: ...
    # No methods for reading content or validation
```

**Dependency Inversion**
```python
# High-level modules (HTMLRenderer) depend on abstractions (ISiteRenderer)
# Low-level modules (FileSystemReader) depend on abstractions (IContentReader)

def cmd_build(args):
    reader: IContentReader = FileSystemReader()  # Concrete implementation
    renderer: ISiteRenderer = HTMLRenderer()     # Concrete implementation

    config = reader.load_site_config(args.site)
    sagas = list(reader.read_sagas(args.site))
    renderer.render_site(config, sagas, ...)
```

### 3. CLEAR Level 5 Compliance

**Cognitive Complexity < 8**
```python
# Bad: High cyclomatic complexity
def process_episode(ep):
    if ep.published:
        if ep.has_video:
            if ep.video_source == "youtube":
                ...  # CC = 3
            elif ep.video_source == "bunny":
                ...  # CC = 4

# Good: Dispatch table pattern
VIDEO_PROCESSORS = {
    "youtube": process_youtube_video,
    "bunny": process_bunny_video
}

def process_episode(ep):
    if not ep.published: return  # Guard clause
    processor = VIDEO_PROCESSORS.get(ep.video_source)
    if processor: processor(ep)  # CC = 1
```

**Strong Typing with Pydantic**
```python
# Runtime validation at data ingestion points
class Episode(BaseModel):
    slug: str = Field(pattern=r'^[a-z0-9-]+$')  # Compile-time type safety
    episode_number: int = Field(ge=1, le=999)    # Range validation
    published_at: datetime                       # Type coercion
```

**Immutable Configurations**
```python
class BrandingConfig(BaseModel):
    model_config = ConfigDict(frozen=True)  # Immutable after creation

    primary_color: str = Field(pattern=r'^#[0-9a-fA-F]{6}$')
```

### 4. GreenOps (Ecological Computing)

**Generator-Based Lazy Loading**
```python
# Bad: Loads 1000 episodes into memory at once
episodes = [parse_episode(f) for f in glob("*.md")]  # 500MB RAM

# Good: Yields one episode at a time
def read_episodes(path: Path) -> Iterator[Episode]:
    for file in sorted(path.glob("*.md")):
        yield parse_episode(file)  # 0.5MB RAM per episode
```

**Memory Efficiency Metrics**
```python
# Traditional approach: O(n) memory
all_sagas = []
for saga_dir in saga_dirs:
    saga = load_saga(saga_dir)  # Load all episodes
    all_sagas.append(saga)
renderer.render_site(all_sagas)  # Needs all sagas in memory

# Generator approach: O(1) memory
for saga in read_sagas(site_id):  # One saga at a time
    renderer.render_saga(saga)     # Render and release
    # Saga garbage collected after rendering
```

---

## System Components

### 1. CLI Entry Point (`run.py`)

**Responsibility**: Command-line interface orchestration

**Commands**:
- `check`: Validate site structure without building
- `build`: Generate static HTML for production
- `serve`: Local development server with Early Hints

**Architecture Pattern**: Command Pattern

```python
# Command interface
class Command(Protocol):
    def execute(self, args: argparse.Namespace) -> None: ...

# Command implementations
def cmd_check(args): ...
def cmd_build(args): ...
def cmd_serve(args): ...

# Command dispatcher
commands = {
    "check": cmd_check,
    "build": cmd_build,
    "serve": cmd_serve
}
```

### 2. Domain Models (`src/core/models.py`)

**Responsibility**: Business rules and data validation

**Key Models**:

```python
# Core Content Models
Episode         # Individual article/video
Saga            # Episode collection (series)
EpisodeMedia    # Media metadata (YouTube, Bunny, audio)

# Configuration Models
SiteConfig      # Multi-tenant site settings
BrandingConfig  # Visual identity (colors, logo)
MediaCDNConfig  # BunnyCDN integration
FeaturesConfig  # Feature flags
SEOConfig       # SEO metadata

# Monetization Models
AffiliateProduct   # Product catalog
AffiliateLink      # Platform-specific links
```

**Design Pattern**: Rich Domain Model

```python
class Saga(BaseModel):
    # Data fields
    slug: str
    title: str
    episodes: list[Episode] = []

    # Computed properties (no DB access)
    @computed_field
    @property
    def episode_count(self) -> int:
        return len(self.episodes)

    # Domain methods (business logic)
    def get_episode_by_number(self, number: int) -> Optional[Episode]:
        for ep in self.episodes:
            if ep.episode_number == number:
                return ep
        return None
```

### 3. Content Reader (`src/adapters/fs_reader.py`)

**Responsibility**: Read and parse content from data sources

**Key Operations**:
- Load site configuration from JSON
- Parse YAML frontmatter from Markdown files
- Normalize asset paths (relative → absolute)
- Lazy-load sagas and episodes via generators

**Architecture Pattern**: Repository Pattern + Adapter Pattern

```python
class FileSystemReader(IContentReader):
    """Adapter: Filesystem → Domain Models"""

    def read_sagas(self, site_id: str, lang: str) -> Iterator[Saga]:
        """Repository method: Fetch all sagas lazily"""
        for saga_dir in self._get_saga_directories(site_id):
            saga = self._load_saga(saga_dir, site_id, lang)
            if saga: yield saga
```

### 4. HTML Renderer (`src/generators/html_renderer.py`)

**Responsibility**: Transform domain models into static HTML

**Key Operations**:
- Render homepage, saga indexes, episode pages
- Inject SEO metadata (Schema.org, Open Graph)
- Generate search index JSON
- Create sitemaps with freshness signals
- Optimize assets (SVG metadata, image compression)

**Architecture Pattern**: Template Method + Strategy Pattern

```python
class HTMLRenderer(ISiteRenderer):
    def render_site(self, config, sagas, posts, products, lang):
        """Template method: Define rendering pipeline"""
        self._copy_static_assets()
        self._render_home(sagas, posts)
        self._render_sagas_index(sagas)
        for saga in sagas:
            self._render_saga(saga, products)  # Strategy
        self._generate_search_index(sagas, posts)
        self._render_sitemap(sagas, posts)
```

---

## Data Flow Architecture

### Build Pipeline Data Flow

```
┌─────────────────────────────────────────────────────────────┐
│ 1. USER INPUT                                               │
│    Command: python run.py build --site specbio             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. CONFIGURATION LOADING                                    │
│    FileSystemReader.load_site_config("specbio")            │
│    ├── Read: data/sites/specbio/config.json               │
│    ├── Migrate: Legacy format → Nested structure          │
│    └── Validate: Pydantic validation                       │
│    Result: SiteConfig instance                             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. LANGUAGE DETECTION                                       │
│    _detect_available_languages("specbio", data_path)       │
│    ├── Scan: series/*/meta.*.yaml files                   │
│    └── Extract: Language codes from filenames              │
│    Result: ["en", "es"]                                    │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. CONTENT LOADING (Per Language)                          │
│    For lang in ["en", "es"]:                               │
│    ├── read_sagas(site_id, lang) → Iterator[Saga]         │
│    │   ├── Load meta.{lang}.yaml                           │
│    │   ├── For each episode directory:                     │
│    │   │   ├── Read content.{lang}.md                      │
│    │   │   ├── Parse YAML frontmatter                      │
│    │   │   ├── Normalize asset paths                       │
│    │   │   └── Validate Episode model                      │
│    │   └── Yield Saga(episodes=[...])                      │
│    ├── read_products(site_id) → ProductCatalog            │
│    │   └── Load products/*.yaml                            │
│    └── read_posts(site_id) → Iterator[Episode]            │
│        └── Load posts/*.md                                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. HTML GENERATION (Per Language)                          │
│    renderer.render_site(config, sagas, posts, products)    │
│    ├── Homepage:                                            │
│    │   ├── Find latest episode (featured content)          │
│    │   ├── Render hero section                             │
│    │   └── Write: /{lang}/index.html                       │
│    ├── Saga Index:                                          │
│    │   └── Write: /{lang}/sagas/index.html                 │
│    ├── For each Saga:                                       │
│    │   ├── Saga Index: /{lang}/sagas/{slug}/index.html     │
│    │   └── For each Episode:                                │
│    │       ├── Load Markdown content                        │
│    │       ├── Render to HTML (markdown-it)                 │
│    │       ├── Apply semantic enhancements (dfn, SVG RDF)   │
│    │       ├── Inject products                              │
│    │       ├── Add navigation (prev/next)                   │
│    │       └── Write: /{lang}/sagas/{slug}/{ep}.html        │
│    ├── Search Index:                                        │
│    │   ├── Aggregate: sagas, episodes, posts               │
│    │   └── Write: /{lang}/api/search-index.json            │
│    └── Sitemap:                                             │
│        ├── Include all pages with lastmod dates            │
│        └── Write: /{lang}/sitemap.xml                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. ROOT METADATA GENERATION                                 │
│    renderer._generate_root_metadata()                       │
│    ├── robots.txt:                                          │
│    │   ├── Allow all crawlers                              │
│    │   ├── Disallow API endpoints                          │
│    │   └── Sitemap directive                               │
│    ├── sitemap.xml (index):                                │
│    │   └── Point to /{lang}/sitemap.xml for each language  │
│    └── index.html (redirect):                              │
│        ├── hreflang tags for all languages                 │
│        ├── Resource hints (preconnect, preload)            │
│        └── Meta refresh to /{default_lang}/                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 7. STATIC ASSET COPYING                                     │
│    shutil.copytree("static", "output/specbio/static")      │
│    ├── CSS: main.css                                        │
│    ├── Images: logo.png, background.png                    │
│    ├── Fonts: Inter, Merriweather                          │
│    └── Episode assets: {site}/{saga}/{episode}/            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 8. ASSET OPTIMIZATION (Optional)                            │
│    optimize_site_images(output_dir, metadata)              │
│    ├── Inject EXIF metadata (author, license)              │
│    └── Optimize image sizes                                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│ 9. BUILD COMPLETE                                           │
│    ✅ Output: output/specbio/                              │
│       Languages built: en, es                               │
│       Root redirects to: /en/                               │
└─────────────────────────────────────────────────────────────┘
```

### Data Transformation Pipeline

```
RAW CONTENT          DOMAIN MODELS         HTML OUTPUT
─────────────        ──────────────        ────────────

config.json    ─────▶  SiteConfig    ─────▶  <meta> tags
   (JSON)            (Pydantic)             (SEO metadata)
                          │
meta.yaml      ─────▶    Saga        ─────▶  sagas/index.html
   (YAML)            (validated)            (saga listing)
                          │
                          ├── Episode[0]
content.md     ─────▶    │   - title   ────▶  episode-01.html
 (Frontmatter         │   - content       (full article)
  + Markdown)         │   - media
                          │   - products
                          │
products.yaml  ─────▶    AffiliateProduct ─▶ Product grid
   (YAML)                (catalog)          (affiliate cards)
```

---

## Layered Architecture

### Layer 1: Presentation (Frontend)

**Technology**: Jinja2 templates + HTMX + Vanilla JS

**Components**:
```
templates/
├── base.html              # Master layout
│   ├── SEO meta tags
│   ├── hreflang links
│   ├── Schema.org JSON-LD
│   ├── Navigation header
│   ├── Search modal
│   └── Footer
├── home.html              # Homepage
├── sagas.html             # Saga index
├── saga_index.html        # Single saga
├── episode.html           # Episode article
└── components/
    ├── _meta_header.html  # SEO metadata
    ├── _breadcrumb.html   # Navigation
    ├── _toc.html          # Table of contents
    └── _product_grid.html # Affiliate products
```

**Responsibilities**:
- Render HTML from domain models
- Inject SEO metadata (OG, Twitter, Schema.org)
- Generate hreflang tags for i18n
- Provide client-side interactivity (search, theme toggle)

### Layer 2: Application (Business Logic)

**Components**:
- `cmd_build()`: Build orchestration
- `cmd_check()`: Validation logic
- `HTMLRenderer`: Rendering pipeline

**Responsibilities**:
- Coordinate content loading and rendering
- Implement build workflow
- Handle multi-language orchestration

### Layer 3: Domain (Core Logic)

**Components**: Pydantic models in `src/core/models.py`

**Responsibilities**:
- Define business entities (Saga, Episode, SiteConfig)
- Enforce validation rules
- Provide computed properties
- Implement domain methods (get_adjacent_episodes)

### Layer 4: Infrastructure (Data Access)

**Components**:
- `FileSystemReader`: Filesystem adapter
- `parse_frontmatter()`: YAML parsing utility

**Responsibilities**:
- Read content from storage
- Parse file formats (JSON, YAML, Markdown)
- Normalize paths
- Handle file I/O errors

---

## Design Patterns

### 1. Repository Pattern

**Intent**: Encapsulate data access logic

**Implementation**:
```python
class IContentReader(ABC):
    """Repository interface"""
    @abstractmethod
    def read_sagas(self, site_id: str) -> Iterator[Saga]: ...

class FileSystemReader(IContentReader):
    """Concrete repository"""
    def read_sagas(self, site_id: str) -> Iterator[Saga]:
        # Filesystem-specific implementation
        ...
```

**Benefits**:
- Domain code doesn't know about filesystem structure
- Easy to add new data sources (API, CMS, database)
- Testable with mock repositories

### 2. Adapter Pattern

**Intent**: Convert one interface to another

**Implementation**:
```python
# FileSystemReader adapts filesystem → IContentReader interface
class FileSystemReader(IContentReader):
    def read_sagas(self, site_id: str) -> Iterator[Saga]:
        # Filesystem operations (glob, read_text)
        # Convert to domain models (Saga, Episode)
        ...
```

**Benefits**:
- Isolates external dependencies (filesystem, YAML parser)
- Domain models don't depend on file formats

### 3. Strategy Pattern

**Intent**: Select algorithm at runtime

**Implementation**:
```python
# Different rendering strategies for content types
class HTMLRenderer:
    def _render_content_item(self, item, template_name, ...):
        """Common rendering logic"""
        tpl = self._get_template(template_name)
        context = self._get_common_vars(...)
        self._write_html(out_path, tpl.render(**context))

# Usage:
renderer._render_content_item(episode, "episode.html", ...)
renderer._render_content_item(post, "post.html", ...)
```

### 4. Template Method Pattern

**Intent**: Define algorithm skeleton, defer steps to subclasses

**Implementation**:
```python
class HTMLRenderer:
    def render_site(self, config, sagas, posts, products):
        """Template method: defines build pipeline"""
        self._copy_static_assets()       # Step 1
        self._render_home(sagas, posts)  # Step 2
        self._render_sagas_index(sagas)  # Step 3
        for saga in sagas:
            self._render_saga(saga, products)  # Step 4 (overrideable)
        self._generate_search_index(...)  # Step 5
        self._render_sitemap(...)         # Step 6
```

### 5. Builder Pattern (Implicit)

**Intent**: Construct complex objects step by step

**Implementation**: Pydantic models with default factories
```python
class Episode(BaseModel):
    # Required fields
    slug: str
    title: str
    episode_number: int
    published_at: datetime

    # Optional fields with defaults
    media: EpisodeMedia = Field(default_factory=EpisodeMedia)
    tags: list[str] = Field(default_factory=list)
    recommended_products: list[str] = Field(default_factory=list)

    # Computed fields
    @computed_field
    @property
    def episode_code(self) -> str:
        return f"S{self.season:02d}E{self.episode_number:02d}"
```

### 6. Generator Pattern (Iterator)

**Intent**: Lazy evaluation for memory efficiency

**Implementation**:
```python
def read_sagas(self, site_id: str) -> Iterator[Saga]:
    """Yields sagas one at a time"""
    for saga_dir in sorted(series_path.iterdir()):
        saga = self._load_saga(saga_dir, site_id)
        if saga: yield saga  # Memory released after consumption
```

---

## Multi-Tenant Strategy

### Tenant Isolation

Each site is completely isolated:

```
data/sites/
├── specbio/              # Tenant 1: Speculative Biology
│   ├── config.json
│   ├── series/
│   └── products/
├── stoic/                # Tenant 2: Stoic Philosophy
│   ├── config.json
│   ├── posts/
│   └── products/
└── newsite/              # Tenant 3: Custom site
    └── ...
```

**Shared Resources**:
- Templates (can be overridden per tenant)
- Static assets (CSS can inject tenant-specific CSS variables)
- Core logic (rendering engine is tenant-agnostic)

**Tenant-Specific Resources**:
- Configuration (colors, logo, domain)
- Content (sagas, episodes, posts)
- Products (affiliate catalog)

### Configuration Injection

```python
# Site-specific branding injected via CSS variables
<style>
:root {
    --brand-primary: {{ site.branding.primary_color }};
    --brand-accent: {{ site.branding.accent_color }};
}
</style>
```

---

## Internationalization Architecture

### Content Localization Strategy

**File-Based Language Detection**:
```python
# Scan for meta.{lang}.yaml files
languages = set()
for saga_dir in series_path.iterdir():
    for meta_file in saga_dir.glob("meta.*.yaml"):
        lang = meta_file.stem.split(".")[1]  # "meta.es.yaml" → "es"
        languages.add(lang)
```

**Fallback Chain**:
```python
# Try language-specific file first, fallback to generic
meta_file = saga_dir / f"meta.{lang}.yaml"  # meta.en.yaml
if not meta_file.exists():
    meta_file = saga_dir / "meta.yaml"      # Generic fallback
```

### URL Structure

```
# English content
/en/
├── index.html
├── sagas/
│   └── saga-01/
│       ├── index.html
│       └── episode-01.html

# Spanish content (mirror structure)
/es/
├── index.html
├── sagas/
│   └── saga-01/
│       ├── index.html
│       └── episodio-01.html
```

### hreflang Implementation

**Page-Level**:
```html
<!-- Episode page hreflang -->
<link rel="alternate" hreflang="en" href="https://site.com/en/sagas/saga-01/episode.html" />
<link rel="alternate" hreflang="es" href="https://site.com/es/sagas/saga-01/episodio.html" />
<link rel="alternate" hreflang="x-default" href="https://site.com/en/sagas/saga-01/episode.html" />
```

**Sitemap-Level**:
```xml
<!-- Root sitemap index -->
<sitemapindex>
    <sitemap>
        <loc>https://site.com/en/sitemap.xml</loc>
    </sitemap>
    <sitemap>
        <loc>https://site.com/es/sitemap.xml</loc>
    </sitemap>
</sitemapindex>
```

---

## SEO Architecture

### Schema.org Knowledge Graph

**Organization-Level**:
```json
{
  "@type": "Organization",
  "@id": "https://site.com/#organization",
  "name": "Exobiology Archives",
  "knowsAbout": ["Astrobiology", "Planetary Science"],
  "sameAs": [
    "https://www.wikidata.org/wiki/Q3625470",
    "https://github.com/org"
  ]
}
```

**Article-Level**:
```json
{
  "@type": "Article",
  "headline": "The Silicon Hypothesis",
  "author": { "@type": "Person", "name": "Author Name" },
  "datePublished": "2025-01-15T10:00:00Z",
  "image": "https://site.com/static/assets/.../hero.jpg",
  "video": {
    "@type": "VideoObject",
    "uploadDate": "2025-01-15T10:00:00Z",
    "duration": "PT930S"
  }
}
```

### Freshness Signals

**Sitemap with lastmod**:
```xml
<url>
    <loc>https://site.com/en/sagas/saga-01/episode.html</loc>
    <lastmod>2025-01-15T10:00:00+00:00</lastmod>
    <priority>0.8</priority>
</url>
```

**HTTP Headers** (Production):
```
Last-Modified: Wed, 15 Jan 2025 10:00:00 GMT
Cache-Control: public, max-age=3600, stale-while-revalidate=86400
```

---

## Performance Architecture

### Core Web Vitals Strategy

**LCP (Largest Contentful Paint)**:
```html
<!-- Hero image optimization -->
<img src="hero.jpg"
     loading="eager"
     fetchpriority="high"
     width="1200"
     height="675">

<!-- Critical CSS inline -->
<style>:root { --brand-accent: #d4af37; }</style>
```

**CLS (Cumulative Layout Shift)**:
```css
/* Fixed dimensions prevent layout shift */
.saga-thumbnail {
    width: 400px;
    height: 225px;
}

/* Content-visibility for below-fold */
.sagas-section {
    content-visibility: auto;
    contain-intrinsic-size: 0 500px;
}
```

**FID (First Input Delay)**:
```html
<!-- Defer non-critical JS -->
<script defer src="analytics.js"></script>

<!-- Passive event listeners -->
<script>
searchInput.addEventListener('input', handler, { passive: true });
</script>
```

### Resource Hints

```html
<!-- DNS prefetch for third-party fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<!-- Preload critical CSS -->
<link rel="preload" href="/static/css/main.css" as="style" fetchpriority="high">

<!-- Preload critical fonts -->
<link rel="preload" href="/static/fonts/inter.woff2" as="font" type="font/woff2" crossorigin>
```

---

## Deployment Architecture

### Production Deployment Options

**Option 1: Static Hosting (Recommended)**
```
GitHub Actions CI/CD
  │
  ├── python run.py build --site specbio
  │
  └── Deploy to:
      ├── Cloudflare Pages  (Recommended: Edge CDN + Analytics)
      ├── Netlify           (Alternative: Good DX)
      ├── Vercel            (Alternative: Next.js-friendly)
      └── AWS S3 + CloudFront (Self-hosted)
```

**Option 2: Self-Hosted**
```
Ubuntu/Debian Server
  │
  ├── Nginx (Web Server)
  │   ├── Serve static files
  │   ├── Gzip compression
  │   ├── HTTP/2 enabled
  │   └── SSL via Let's Encrypt
  │
  └── GitHub Actions (Deployment)
      └── rsync output/ → /var/www/html/
```

### CI/CD Pipeline

```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Build site
        run: python run.py build --site specbio

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          directory: output/specbio
```

---

## Security Architecture

### Content Security

**Input Validation**:
```python
# All content validated by Pydantic before rendering
class Episode(BaseModel):
    slug: str = Field(pattern=r'^[a-z0-9-]+$')  # XSS prevention
    title: str = Field(max_length=200)           # Length limits
```

**Output Escaping**:
```jinja2
{# Jinja2 autoescape enabled by default #}
<h1>{{ episode.title }}</h1>  <!-- HTML-escaped -->

{# Raw HTML only for trusted Markdown #}
{{ content | safe }}  <!-- Rendered Markdown (trusted source) -->
```

### Static Site Security Benefits

- **No Server-Side Code**: Eliminates RCE, SQLi, XXE vulnerabilities
- **No Authentication**: No credentials to steal
- **No Database**: No data breaches
- **Immutable Deploys**: Rollback to any previous version instantly

### Security Headers (Production)

```nginx
# Nginx configuration
add_header X-Content-Type-Options "nosniff" always;
add_header X-Frame-Options "DENY" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "no-referrer-when-downgrade" always;
add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;" always;
```

---

## Scalability & Extensibility

### Horizontal Scalability

**Static Sites Scale Infinitely**:
- CDN edge caching (Cloudflare, Fastly)
- No database bottlenecks
- No server load balancing needed

**Build Parallelization**:
```python
# Future: Parallel episode rendering
from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor(max_workers=4) as executor:
    futures = [
        executor.submit(renderer.render_episode, ep)
        for ep in saga.episodes
    ]
```

### Extension Points

**1. New Content Sources**
```python
class APIContentReader(IContentReader):
    """Read content from REST API"""
    def read_sagas(self, site_id: str) -> Iterator[Saga]:
        response = requests.get(f"https://api.example.com/sagas")
        for saga_data in response.json():
            yield Saga(**saga_data)
```

**2. New Output Formats**
```python
class PDFRenderer(ISiteRenderer):
    """Render sagas as PDF e-books"""
    def render_site(self, config, sagas, ...):
        for saga in sagas:
            pdf = self._generate_pdf(saga)
            pdf.save(f"output/{saga.slug}.pdf")
```

**3. New Deployment Targets**
```python
class S3Deployer:
    """Deploy to AWS S3 + CloudFront"""
    def deploy(self, output_dir: Path, bucket: str):
        s3 = boto3.client('s3')
        for file in output_dir.rglob("*"):
            s3.upload_file(file, bucket, str(file.relative_to(output_dir)))
```

---

## Future Architecture Enhancements

### 1. Incremental Builds

**Current**: Full rebuild on every change
**Future**: Only rebuild changed content

```python
# Cache previous build state
build_cache = {
    "sagas": {"saga-01": "hash123", "saga-02": "hash456"},
    "config": "hash789"
}

# Compare content hashes
if current_hash != build_cache.get(saga_id):
    renderer.render_saga(saga)  # Only rebuild this saga
```

### 2. Plugin System

```python
class IPlugin(ABC):
    @abstractmethod
    def on_episode_render(self, episode: Episode, html: str) -> str: ...

class ReadingTimePlugin(IPlugin):
    def on_episode_render(self, episode, html):
        word_count = len(html.split())
        reading_time = word_count // 200
        return f'<div class="reading-time">{reading_time} min</div>' + html
```

### 3. Live Preview Server

```python
# Watch filesystem for changes
from watchdog.observers import Observer

class ContentChangeHandler:
    def on_modified(self, event):
        # Rebuild affected page
        # Notify browser via WebSocket
        pass
```

---

## Conclusion

Z-Content Platform achieves elite architecture through:

1. **Clean Architecture**: Domain independence, testability, extensibility
2. **SOLID Principles**: Single responsibility, open/closed, dependency inversion
3. **Performance**: Lazy loading, static site speed, edge CDN delivery
4. **SEO Excellence**: Schema.org graphs, hreflang, freshness signals
5. **Multi-Tenancy**: Complete tenant isolation with shared infrastructure

The architecture enables **content sovereignty** (own your platform), **semantic authority** (E-E-A-T signals), and **predictive performance** (sub-second page loads).

---

**See Also**:
- [CODE_WIKI.md](CODE_WIKI.md) - Implementation details
- [CAPABILITIES.md](CAPABILITIES.md) - Feature documentation
- [HOW_TO.md](HOW_TO.md) - Usage workflows

---

**Document Version**: 2.0.0
**Last Updated**: 2025-12-22
**Maintainer**: Z-Content Platform Architecture Team
